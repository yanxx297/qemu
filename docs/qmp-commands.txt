                        QMP Supported Commands
                        ----------------------

This document describes all commands currently supported by QMP.

Most of the time their usage is exactly the same as in the user Monitor, this
means that any other document which also describe commands (the manpage,
QEMU's manual, etc) can and should be consulted.

QMP has two types of commands: regular and query commands. Regular commands
usually change the Virtual Machine's state someway, while query commands just
return information. The sections below are divided accordingly.

It's important to observe that all communication examples are formatted in
a reader-friendly way, so that they're easier to understand. However, in real
protocol usage, they're emitted as a single line.

Also, the following notation is used to denote data flow:

-> data issued by the Client
<- Server data response

Please, refer to the QMP specification (docs/qmp-spec.txt) for detailed
information on the Server command and response formats.

NOTE: This document is temporary and will be replaced soon.

1. Stability Considerations
===========================

The current QMP command set (described in this file) may be useful for a
number of use cases, however it's limited and several commands have bad
defined semantics, specially with regard to command completion.

These problems are going to be solved incrementally in the next QEMU releases
and we're going to establish a deprecation policy for badly defined commands.

If you're planning to adopt QMP, please observe the following:

    1. The deprecation policy will take effect and be documented soon, please
       check the documentation of each used command as soon as a new release of
       QEMU is available

    2. DO NOT rely on anything which is not explicit documented

    3. Errors, in special, are not documented. Applications should NOT check
       for specific errors classes or data (it's strongly recommended to only
       check for the "error" key)

2. Regular Commands
===================

Server's responses in the examples below are always a success response, please
refer to the QMP specification for more details on error responses.

eject
-----

Eject a removable medium.

Arguments:

- "force": force ejection (json-bool, optional)
- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)

Example:

-> { "execute": "eject", "arguments": { "id": "ide0-1-0" } }
<- { "return": {} }

Note: The "force" argument defaults to false.

device_add
----------

Add a device.

Arguments:

- "driver": the name of the new device's driver (json-string)
- "bus": the device's parent bus (device tree path, json-string, optional)
- "id": the device's ID, must be unique (json-string)
- device properties

Example:

-> { "execute": "device_add", "arguments": { "driver": "e1000", "id": "net1" } }
<- { "return": {} }

Notes:

(1) For detailed information about this command, please refer to the
    'docs/qdev-device-use.txt' file.

(2) It's possible to list device properties by running QEMU with the
    "-device DEVICE,\?" command-line argument, where DEVICE is the device's name

cpu
---

Set the default CPU.

Arguments:

- "index": the CPU's index (json-int)

Example:

-> { "execute": "cpu", "arguments": { "index": 0 } }
<- { "return": {} }

Note: CPUs' indexes are obtained with the 'query-cpus' command.

xen-load-devices-state
----------------------

Load the state of all devices from file. The RAM and the block devices
of the VM are not loaded by this command.

Arguments:

- "filename": the file to load the state of the devices from as binary
data. See xen-save-devices-state.txt for a description of the binary
format.

Example:

-> { "execute": "xen-load-devices-state",
     "arguments": { "filename": "/tmp/resume" } }
<- { "return": {} }

migrate-set-cache-size
----------------------

Set cache size to be used by XBZRLE migration, the cache size will be rounded
down to the nearest power of 2

Arguments:

- "value": cache size in bytes (json-int)

Example:

-> { "execute": "migrate-set-cache-size", "arguments": { "value": 536870912 } }
<- { "return": {} }

x-colo-lost-heartbeat
--------------------

Tell COLO that heartbeat is lost, a failover or takeover is needed.

Example:

-> { "execute": "x-colo-lost-heartbeat" }
<- { "return": {} }

query-dump
----------

Query background dump status.

Arguments: None.

Example:

-> { "execute": "query-dump" }
<- { "return": { "status": "active", "completed": 1024000,
                 "total": 2048000 } }

block-stream
------------

Copy data from a backing file into a block device.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": The device name or node-name of a root node (json-string)
- "base": The file name of the backing image above which copying starts.
          It cannot be set if 'base-node' is also set (json-string, optional)
- "base-node": the node name of the backing image above which copying starts.
               It cannot be set if 'base' is also set.
               (json-string, optional) (Since 2.8)
- "backing-file": The backing file string to write into the active layer. This
                  filename is not validated.

                  If a pathname string is such that it cannot be resolved by
                  QEMU, that means that subsequent QMP or HMP commands must use
                  node-names for the image in question, as filename lookup
                  methods will fail.

                  If not specified, QEMU will automatically determine the
                  backing file string to use, or error out if there is no
                  obvious choice.  Care should be taken when specifying the
                  string, to specify a valid filename or protocol.
                  (json-string, optional) (Since 2.1)
- "speed":  the maximum speed, in bytes per second (json-int, optional)
- "on-error": the action to take on an error (default 'report').  'stop' and
              'enospc' can only be used if the block device supports io-status.
              (json-string, optional) (Since 2.1)

Example:

-> { "execute": "block-stream", "arguments": { "device": "virtio0",
                                               "base": "/tmp/master.qcow2" } }
<- { "return": {} }

block-commit
------------

Live commit of data from overlay image nodes into backing nodes - i.e., writes
data between 'top' and 'base' into 'base'.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": The device name or node-name of a root node (json-string)
- "base": The file name of the backing image to write data into.
          If not specified, this is the deepest backing image
          (json-string, optional)
- "top":  The file name of the backing image within the image chain,
          which contains the topmost data to be committed down. If
          not specified, this is the active layer. (json-string, optional)

- backing-file:     The backing file string to write into the overlay
                    image of 'top'.  If 'top' is the active layer,
                    specifying a backing file string is an error. This
                    filename is not validated.

                    If a pathname string is such that it cannot be
                    resolved by QEMU, that means that subsequent QMP or
                    HMP commands must use node-names for the image in
                    question, as filename lookup methods will fail.

                    If not specified, QEMU will automatically determine
                    the backing file string to use, or error out if
                    there is no obvious choice. Care should be taken
                    when specifying the string, to specify a valid
                    filename or protocol.
                    (json-string, optional) (Since 2.1)

          If top == base, that is an error.
          If top == active, the job will not be completed by itself,
          user needs to complete the job with the block-job-complete
          command after getting the ready event. (Since 2.0)

          If the base image is smaller than top, then the base image
          will be resized to be the same size as top.  If top is
          smaller than the base image, the base will not be
          truncated.  If you want the base image size to match the
          size of the smaller top, you can safely truncate it
          yourself once the commit operation successfully completes.
          (json-string)
- "speed":  the maximum speed, in bytes per second (json-int, optional)


Example:

-> { "execute": "block-commit", "arguments": { "device": "virtio0",
                                              "top": "/tmp/snap1.qcow2" } }
<- { "return": {} }

drive-backup
------------

Start a point-in-time copy of a block device to a new destination.  The
status of ongoing drive-backup operations can be checked with
query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
The operation can be stopped before it has completed using the
block-job-cancel command.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": the device name or node-name of a root node which should be copied.
            (json-string)
- "target": the target of the new image. If the file exists, or if it is a
            device, the existing file/device will be used as the new
            destination.  If it does not exist, a new file will be created.
            (json-string)
- "format": the format of the new destination, default is to probe if 'mode' is
            'existing', else the format of the source
            (json-string, optional)
- "sync": what parts of the disk image should be copied to the destination;
  possibilities include "full" for all the disk, "top" for only the sectors
  allocated in the topmost image, "incremental" for only the dirty sectors in
  the bitmap, or "none" to only replicate new I/O (MirrorSyncMode).
- "bitmap": dirty bitmap name for sync==incremental. Must be present if sync
            is "incremental", must NOT be present otherwise.
- "mode": whether and how QEMU should create a new image
          (NewImageMode, optional, default 'absolute-paths')
- "speed": the maximum speed, in bytes per second (json-int, optional)
- "compress": true to compress data, if the target format supports it.
              (json-bool, optional, default false)
- "on-source-error": the action to take on an error on the source, default
                     'report'.  'stop' and 'enospc' can only be used
                     if the block device supports io-status.
                     (BlockdevOnError, optional)
- "on-target-error": the action to take on an error on the target, default
                     'report' (no limitations, since this applies to
                     a different block device than device).
                     (BlockdevOnError, optional)

Example:
-> { "execute": "drive-backup", "arguments": { "device": "drive0",
                                               "sync": "full",
                                               "target": "backup.img" } }
<- { "return": {} }

blockdev-backup
---------------

The device version of drive-backup: this command takes an existing named device
as backup target.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": the device name or node-name of a root node which should be copied.
            (json-string)
- "target": the name of the backup target device. (json-string)
- "sync": what parts of the disk image should be copied to the destination;
          possibilities include "full" for all the disk, "top" for only the
          sectors allocated in the topmost image, or "none" to only replicate
          new I/O (MirrorSyncMode).
- "speed": the maximum speed, in bytes per second (json-int, optional)
- "compress": true to compress data, if the target format supports it.
              (json-bool, optional, default false)
- "on-source-error": the action to take on an error on the source, default
                     'report'.  'stop' and 'enospc' can only be used
                     if the block device supports io-status.
                     (BlockdevOnError, optional)
- "on-target-error": the action to take on an error on the target, default
                     'report' (no limitations, since this applies to
                     a different block device than device).
                     (BlockdevOnError, optional)

Example:
-> { "execute": "blockdev-backup", "arguments": { "device": "src-id",
                                                  "sync": "full",
                                                  "target": "tgt-id" } }
<- { "return": {} }

block-dirty-bitmap-add
----------------------
Since 2.4

Create a dirty bitmap with a name on the device, and start tracking the writes.

Arguments:

- "node": device/node on which to create dirty bitmap (json-string)
- "name": name of the new dirty bitmap (json-string)
- "granularity": granularity to track writes with (int, optional)

Example:

-> { "execute": "block-dirty-bitmap-add", "arguments": { "node": "drive0",
                                                   "name": "bitmap0" } }
<- { "return": {} }

block-dirty-bitmap-remove
-------------------------
Since 2.4

Stop write tracking and remove the dirty bitmap that was created with
block-dirty-bitmap-add.

Arguments:

- "node": device/node on which to remove dirty bitmap (json-string)
- "name": name of the dirty bitmap to remove (json-string)

Example:

-> { "execute": "block-dirty-bitmap-remove", "arguments": { "node": "drive0",
                                                      "name": "bitmap0" } }
<- { "return": {} }

block-dirty-bitmap-clear
------------------------
Since 2.4

Reset the dirty bitmap associated with a node so that an incremental backup
from this point in time forward will only backup clusters modified after this
clear operation.

Arguments:

- "node": device/node on which to remove dirty bitmap (json-string)
- "name": name of the dirty bitmap to remove (json-string)

Example:

-> { "execute": "block-dirty-bitmap-clear", "arguments": { "node": "drive0",
                                                           "name": "bitmap0" } }
<- { "return": {} }

blockdev-snapshot-internal-sync
-------------------------------

Synchronously take an internal snapshot of a block device when the format of
image used supports it.  If the name is an empty string, or a snapshot with
name already exists, the operation will fail.

Arguments:

- "device": the device name or node-name of a root node to snapshot
            (json-string)
- "name": name of the new snapshot (json-string)

Example:

-> { "execute": "blockdev-snapshot-internal-sync",
                "arguments": { "device": "ide-hd0",
                               "name": "snapshot0" }
   }
<- { "return": {} }

blockdev-snapshot-delete-internal-sync
--------------------------------------

Synchronously delete an internal snapshot of a block device when the format of
image used supports it.  The snapshot is identified by name or id or both.  One
of name or id is required.  If the snapshot is not found, the operation will
fail.

Arguments:

- "device": the device name or node-name of a root node (json-string)
- "id": ID of the snapshot (json-string, optional)
- "name": name of the snapshot (json-string, optional)

Example:

-> { "execute": "blockdev-snapshot-delete-internal-sync",
                "arguments": { "device": "ide-hd0",
                               "name": "snapshot0" }
   }
<- { "return": {
                   "id": "1",
                   "name": "snapshot0",
                   "vm-state-size": 0,
                   "date-sec": 1000012,
                   "date-nsec": 10,
                   "vm-clock-sec": 100,
                   "vm-clock-nsec": 20
     }
   }

drive-mirror
------------

Start mirroring a block device's writes to a new destination. target
specifies the target of the new image. If the file exists, or if it is
a device, it will be used as the new destination for writes. If it does not
exist, a new file will be created. format specifies the format of the
mirror image, default is to probe if mode='existing', else the format
of the source.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": the device name or node-name of a root node whose writes should be
            mirrored. (json-string)
- "target": name of new image file (json-string)
- "format": format of new image (json-string, optional)
- "node-name": the name of the new block driver state in the node graph
               (json-string, optional)
- "replaces": the block driver node name to replace when finished
              (json-string, optional)
- "mode": how an image file should be created into the target
  file/device (NewImageMode, optional, default 'absolute-paths')
- "speed": maximum speed of the streaming job, in bytes per second
  (json-int)
- "granularity": granularity of the dirty bitmap, in bytes (json-int, optional)
- "buf-size": maximum amount of data in flight from source to target, in bytes
  (json-int, default 10M)
- "sync": what parts of the disk image should be copied to the destination;
  possibilities include "full" for all the disk, "top" for only the sectors
  allocated in the topmost image, or "none" to only replicate new I/O
  (MirrorSyncMode).
- "on-source-error": the action to take on an error on the source
  (BlockdevOnError, default 'report')
- "on-target-error": the action to take on an error on the target
  (BlockdevOnError, default 'report')
- "unmap": whether the target sectors should be discarded where source has only
  zeroes. (json-bool, optional, default true)

The default value of the granularity is the image cluster size clamped
between 4096 and 65536, if the image format defines one.  If the format
does not define a cluster size, the default value of the granularity
is 65536.


Example:

-> { "execute": "drive-mirror", "arguments": { "device": "ide-hd0",
                                               "target": "/some/place/my-image",
                                               "sync": "full",
                                               "format": "qcow2" } }
<- { "return": {} }

blockdev-mirror
------------

Start mirroring a block device's writes to another block device. target
specifies the target of mirror operation.

Arguments:

- "job-id": Identifier for the newly-created block job. If omitted,
            the device name will be used. (json-string, optional)
- "device": The device name or node-name of a root node whose writes should be
            mirrored (json-string)
- "target": device name to mirror to (json-string)
- "replaces": the block driver node name to replace when finished
              (json-string, optional)
- "speed": maximum speed of the streaming job, in bytes per second
  (json-int)
- "granularity": granularity of the dirty bitmap, in bytes (json-int, optional)
- "buf_size": maximum amount of data in flight from source to target, in bytes
  (json-int, default 10M)
- "sync": what parts of the disk image should be copied to the destination;
  possibilities include "full" for all the disk, "top" for only the sectors
  allocated in the topmost image, or "none" to only replicate new I/O
  (MirrorSyncMode).
- "on-source-error": the action to take on an error on the source
  (BlockdevOnError, default 'report')
- "on-target-error": the action to take on an error on the target
  (BlockdevOnError, default 'report')

The default value of the granularity is the image cluster size clamped
between 4096 and 65536, if the image format defines one.  If the format
does not define a cluster size, the default value of the granularity
is 65536.

Example:

-> { "execute": "blockdev-mirror", "arguments": { "device": "ide-hd0",
                                                  "target": "target0",
                                                  "sync": "full" } }
<- { "return": {} }

change-backing-file
-------------------
Since: 2.1

Change the backing file in the image file metadata.  This does not cause
QEMU to reopen the image file to reparse the backing filename (it may,
however, perform a reopen to change permissions from r/o -> r/w -> r/o,
if needed). The new backing file string is written into the image file
metadata, and the QEMU internal strings are updated.

Arguments:

- "image-node-name":    The name of the block driver state node of the
                        image to modify.  The "device" is argument is used to
                        verify "image-node-name" is in the chain described by
                        "device".
                        (json-string, optional)

- "device":             The device name or node-name of the root node that owns
                        image-node-name.
                        (json-string)

- "backing-file":       The string to write as the backing file.  This string is
                        not validated, so care should be taken when specifying
                        the string or the image chain may not be able to be
                        reopened again.
                        (json-string)

Returns: Nothing on success
         If "device" does not exist or cannot be determined, DeviceNotFound

block_set_io_throttle
------------

Change I/O throttle limits for a block drive.

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)
- "bps": total throughput limit in bytes per second (json-int)
- "bps_rd": read throughput limit in bytes per second (json-int)
- "bps_wr": write throughput limit in bytes per second (json-int)
- "iops": total I/O operations per second (json-int)
- "iops_rd": read I/O operations per second (json-int)
- "iops_wr": write I/O operations per second (json-int)
- "bps_max": total throughput limit during bursts, in bytes (json-int, optional)
- "bps_rd_max": read throughput limit during bursts, in bytes (json-int, optional)
- "bps_wr_max": write throughput limit during bursts, in bytes (json-int, optional)
- "iops_max": total I/O operations per second during bursts (json-int, optional)
- "iops_rd_max": read I/O operations per second during bursts (json-int, optional)
- "iops_wr_max": write I/O operations per second during bursts (json-int, optional)
- "bps_max_length": maximum length of the @bps_max burst period, in seconds (json-int, optional)
- "bps_rd_max_length": maximum length of the @bps_rd_max burst period, in seconds (json-int, optional)
- "bps_wr_max_length": maximum length of the @bps_wr_max burst period, in seconds (json-int, optional)
- "iops_max_length": maximum length of the @iops_max burst period, in seconds (json-int, optional)
- "iops_rd_max_length": maximum length of the @iops_rd_max burst period, in seconds (json-int, optional)
- "iops_wr_max_length": maximum length of the @iops_wr_max burst period, in seconds (json-int, optional)
- "iops_size":  I/O size in bytes when limiting (json-int, optional)
- "group": throttle group name (json-string, optional)

Example:

-> { "execute": "block_set_io_throttle", "arguments": { "id": "ide0-1-0",
                                               "bps": 1000000,
                                               "bps_rd": 0,
                                               "bps_wr": 0,
                                               "iops": 0,
                                               "iops_rd": 0,
                                               "iops_wr": 0,
                                               "bps_max": 8000000,
                                               "bps_rd_max": 0,
                                               "bps_wr_max": 0,
                                               "iops_max": 0,
                                               "iops_rd_max": 0,
                                               "iops_wr_max": 0,
                                               "bps_max_length": 60,
                                               "iops_size": 0 } }
<- { "return": {} }

qmp_capabilities
----------------

Enable QMP capabilities.

Arguments: None.

Example:

-> { "execute": "qmp_capabilities" }
<- { "return": {} }

Note: This command must be issued before issuing any other command.

3. Query Commands
=================


query-version
-------------

Show QEMU version.

Return a json-object with the following information:

- "qemu": A json-object containing three integer values:
    - "major": QEMU's major version (json-int)
    - "minor": QEMU's minor version (json-int)
    - "micro": QEMU's micro version (json-int)
- "package": package's version (json-string)

Example:

-> { "execute": "query-version" }
<- {
      "return":{
         "qemu":{
            "major":0,
            "minor":11,
            "micro":5
         },
         "package":""
      }
   }

query-commands
--------------

List QMP available commands.

Each command is represented by a json-object, the returned value is a json-array
of all commands.

Each json-object contain:

- "name": command's name (json-string)

Example:

-> { "execute": "query-commands" }
<- {
      "return":[
         {
            "name":"query-balloon"
         },
         {
            "name":"system_powerdown"
         }
      ]
   }

Note: This example has been shortened as the real response is too long.

query-qmp-schema
----------------

Return the QMP wire schema.  The returned value is a json-array of
named schema entities.  Entities are commands, events and various
types.  See docs/qapi-code-gen.txt for information on their structure
and intended use.

blockdev-add
------------

Add a block device.

This command is still a work in progress.  It doesn't support all
block drivers among other things.  Stay away from it unless you want
to help with its development.

For the arguments, see the QAPI schema documentation of BlockdevOptions.

Example (1):

-> { "execute": "blockdev-add",
    "arguments": { "driver": "qcow2",
                   "file": { "driver": "file",
                             "filename": "test.qcow2" } } }
<- { "return": {} }

Example (2):

-> { "execute": "blockdev-add",
     "arguments": {
         "driver": "qcow2",
         "node-name": "my_disk",
         "discard": "unmap",
         "cache": {
             "direct": true,
             "writeback": true
         },
         "file": {
             "driver": "file",
             "filename": "/tmp/test.qcow2"
         },
         "backing": {
             "driver": "raw",
             "file": {
                 "driver": "file",
                 "filename": "/dev/fdset/4"
             }
         }
       }
     }

<- { "return": {} }

x-blockdev-del
------------
Since 2.5

Deletes a block device that has been added using blockdev-add.
The command will fail if the node is attached to a device or is
otherwise being used.

This command is still a work in progress and is considered
experimental. Stay away from it unless you want to help with its
development.

Arguments:

- "node-name": Name of the graph node to delete (json-string)

Example:

-> { "execute": "blockdev-add",
     "arguments": {
         "driver": "qcow2",
         "node-name": "node0",
         "file": {
             "driver": "file",
             "filename": "test.qcow2"
         }
     }
   }

<- { "return": {} }

-> { "execute": "x-blockdev-del",
     "arguments": { "node-name": "node0" }
   }
<- { "return": {} }

blockdev-open-tray
------------------

Opens a block device's tray. If there is a block driver state tree inserted as a
medium, it will become inaccessible to the guest (but it will remain associated
to the block device, so closing the tray will make it accessible again).

If the tray was already open before, this will be a no-op.

Once the tray opens, a DEVICE_TRAY_MOVED event is emitted. There are cases in
which no such event will be generated, these include:
- if the guest has locked the tray, @force is false and the guest does not
  respond to the eject request
- if the BlockBackend denoted by @device does not have a guest device attached
  to it
- if the guest device does not have an actual tray and is empty, for instance
  for floppy disk drives

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)
- "force": if false (the default), an eject request will be sent to the guest if
           it has locked the tray (and the tray will not be opened immediately);
           if true, the tray will be opened regardless of whether it is locked
           (json-bool, optional)

Example:

-> { "execute": "blockdev-open-tray",
     "arguments": { "id": "ide0-1-0" } }

<- { "timestamp": { "seconds": 1418751016,
                    "microseconds": 716996 },
     "event": "DEVICE_TRAY_MOVED",
     "data": { "device": "ide1-cd0",
               "id": "ide0-1-0",
               "tray-open": true } }

<- { "return": {} }

blockdev-close-tray
-------------------

Closes a block device's tray. If there is a block driver state tree associated
with the block device (which is currently ejected), that tree will be loaded as
the medium.

If the tray was already closed before, this will be a no-op.

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)

Example:

-> { "execute": "blockdev-close-tray",
     "arguments": { "id": "ide0-1-0" } }

<- { "timestamp": { "seconds": 1418751345,
                    "microseconds": 272147 },
     "event": "DEVICE_TRAY_MOVED",
     "data": { "device": "ide1-cd0",
               "id": "ide0-1-0",
               "tray-open": false } }

<- { "return": {} }

x-blockdev-remove-medium
------------------------

Removes a medium (a block driver state tree) from a block device. That block
device's tray must currently be open (unless there is no attached guest device).

If the tray is open and there is no medium inserted, this will be a no-op.

This command is still a work in progress and is considered experimental.
Stay away from it unless you want to help with its development.

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)

Example:

-> { "execute": "x-blockdev-remove-medium",
     "arguments": { "id": "ide0-1-0" } }

<- { "error": { "class": "GenericError",
                "desc": "Tray of device 'ide0-1-0' is not open" } }

-> { "execute": "blockdev-open-tray",
     "arguments": { "id": "ide0-1-0" } }

<- { "timestamp": { "seconds": 1418751627,
                    "microseconds": 549958 },
     "event": "DEVICE_TRAY_MOVED",
     "data": { "device": "ide1-cd0",
               "id": "ide0-1-0",
               "tray-open": true } }

<- { "return": {} }

-> { "execute": "x-blockdev-remove-medium",
     "arguments": { "device": "ide0-1-0" } }

<- { "return": {} }

x-blockdev-insert-medium
------------------------

Inserts a medium (a block driver state tree) into a block device. That block
device's tray must currently be open (unless there is no attached guest device)
and there must be no medium inserted already.

This command is still a work in progress and is considered experimental.
Stay away from it unless you want to help with its development.

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)
- "node-name": root node of the BDS tree to insert into the block device

Example:

-> { "execute": "blockdev-add",
     "arguments": { { "node-name": "node0",
                      "driver": "raw",
                      "file": { "driver": "file",
                                "filename": "fedora.iso" } } }

<- { "return": {} }

-> { "execute": "x-blockdev-insert-medium",
     "arguments": { "id": "ide0-1-0",
                    "node-name": "node0" } }

<- { "return": {} }

x-blockdev-change
-----------------

Dynamically reconfigure the block driver state graph. It can be used
to add, remove, insert or replace a graph node. Currently only the
Quorum driver implements this feature to add or remove its child. This
is useful to fix a broken quorum child.

If @node is specified, it will be inserted under @parent. @child
may not be specified in this case. If both @parent and @child are
specified but @node is not, @child will be detached from @parent.

Arguments:
- "parent": the id or name of the parent node (json-string)
- "child": the name of a child under the given parent node (json-string, optional)
- "node": the name of the node that will be added (json-string, optional)

Note: this command is experimental, and not a stable API. It doesn't
support all kinds of operations, all kinds of children, nor all block
drivers.

Warning: The data in a new quorum child MUST be consistent with that of
the rest of the array.

Example:

Add a new node to a quorum
-> { "execute": "blockdev-add",
     "arguments": { "driver": "raw",
                    "node-name": "new_node",
                    "file": { "driver": "file",
                              "filename": "test.raw" } } }
<- { "return": {} }
-> { "execute": "x-blockdev-change",
     "arguments": { "parent": "disk1",
                    "node": "new_node" } }
<- { "return": {} }

Delete a quorum's node
-> { "execute": "x-blockdev-change",
     "arguments": { "parent": "disk1",
                    "child": "children.1" } }
<- { "return": {} }

query-named-block-nodes
-----------------------

Return a list of BlockDeviceInfo for all the named block driver nodes

Example:

-> { "execute": "query-named-block-nodes" }
<- { "return": [ { "ro":false,
                   "drv":"qcow2",
                   "encrypted":false,
                   "file":"disks/test.qcow2",
                   "node-name": "my-node",
                   "backing_file_depth":1,
                   "bps":1000000,
                   "bps_rd":0,
                   "bps_wr":0,
                   "iops":1000000,
                   "iops_rd":0,
                   "iops_wr":0,
                   "bps_max": 8000000,
                   "bps_rd_max": 0,
                   "bps_wr_max": 0,
                   "iops_max": 0,
                   "iops_rd_max": 0,
                   "iops_wr_max": 0,
                   "iops_size": 0,
                   "write_threshold": 0,
                   "image":{
                      "filename":"disks/test.qcow2",
                      "format":"qcow2",
                      "virtual-size":2048000,
                      "backing_file":"base.qcow2",
                      "full-backing-filename":"disks/base.qcow2",
                      "backing-filename-format":"qcow2",
                      "snapshots":[
                         {
                            "id": "1",
                            "name": "snapshot1",
                            "vm-state-size": 0,
                            "date-sec": 10000200,
                            "date-nsec": 12,
                            "vm-clock-sec": 206,
                            "vm-clock-nsec": 30
                         }
                      ],
                      "backing-image":{
                          "filename":"disks/base.qcow2",
                          "format":"qcow2",
                          "virtual-size":2048000
                      }
                   } } ] }

blockdev-change-medium
----------------------

Changes the medium inserted into a block device by ejecting the current medium
and loading a new image file which is inserted as the new medium.

Arguments:

- "device": block device name (deprecated, use @id instead)
            (json-string, optional)
- "id": the name or QOM path of the guest device (json-string, optional)
- "filename": filename of the new image (json-string)
- "format": format of the new image (json-string, optional)
- "read-only-mode": new read-only mode (json-string, optional)
          - Possible values: "retain" (default), "read-only", "read-write"

Examples:

1. Change a removable medium

-> { "execute": "blockdev-change-medium",
             "arguments": { "id": "ide0-1-0",
                            "filename": "/srv/images/Fedora-12-x86_64-DVD.iso",
                            "format": "raw" } }
<- { "return": {} }

2. Load a read-only medium into a writable drive

-> { "execute": "blockdev-change-medium",
             "arguments": { "id": "floppyA",
                            "filename": "/srv/images/ro.img",
                            "format": "raw",
                            "read-only-mode": "retain" } }

<- { "error":
     { "class": "GenericError",
       "desc": "Could not open '/srv/images/ro.img': Permission denied" } }

-> { "execute": "blockdev-change-medium",
             "arguments": { "id": "floppyA",
                            "filename": "/srv/images/ro.img",
                            "format": "raw",
                            "read-only-mode": "read-only" } }

<- { "return": {} }

trace-event-get-state
---------------------

Query the state of events.

Arguments:

- "name": Event name pattern (json-string).
- "vcpu": The vCPU to query, any vCPU by default (json-int, optional).

An event is returned if:
- its name matches the "name" pattern, and
- if "vcpu" is given, the event has the "vcpu" property.

Therefore, if "vcpu" is given, the operation will only match per-vCPU events,
returning their state on the specified vCPU. Special case: if "name" is an exact
match, "vcpu" is given and the event does not have the "vcpu" property, an error
is returned.

Example:

-> { "execute": "trace-event-get-state", "arguments": { "name": "qemu_memalign" } }
<- { "return": [ { "name": "qemu_memalign", "state": "disabled" } ] }

trace-event-set-state
---------------------

Set the state of events.

Arguments:

- "name": Event name pattern (json-string).
- "enable": Whether to enable or disable the event (json-bool).
- "ignore-unavailable": Whether to ignore errors for events that cannot be
  changed (json-bool, optional).
- "vcpu": The vCPU to act upon, all vCPUs by default (json-int, optional).

An event's state is modified if:
- its name matches the "name" pattern, and
- if "vcpu" is given, the event has the "vcpu" property.

Therefore, if "vcpu" is given, the operation will only match per-vCPU events,
setting their state on the specified vCPU. Special case: if "name" is an exact
match, "vcpu" is given and the event does not have the "vcpu" property, an error
is returned.

Example:

-> { "execute": "trace-event-set-state", "arguments": { "name": "qemu_memalign", "enable": "true" } }
<- { "return": {} }

block-set-write-threshold
------------

Change the write threshold for a block drive. The threshold is an offset,
thus must be non-negative. Default is no write threshold.
Setting the threshold to zero disables it.

Arguments:

- "node-name": the node name in the block driver state graph (json-string)
- "write-threshold": the write threshold in bytes (json-int)

Example:

-> { "execute": "block-set-write-threshold",
  "arguments": { "node-name": "mydev",
                 "write-threshold": 17179869184 } }
<- { "return": {} }

Show rocker switch
------------------

Arguments:

- "name": switch name

Example:

-> { "execute": "query-rocker", "arguments": { "name": "sw1" } }
<- { "return": {"name": "sw1", "ports": 2, "id": 1327446905938}}

Show rocker switch ports
------------------------

Arguments:

- "name": switch name

Example:

-> { "execute": "query-rocker-ports", "arguments": { "name": "sw1" } }
<- { "return": [ {"duplex": "full", "enabled": true, "name": "sw1.1",
                  "autoneg": "off", "link-up": true, "speed": 10000},
                 {"duplex": "full", "enabled": true, "name": "sw1.2",
                  "autoneg": "off", "link-up": true, "speed": 10000}
   ]}

Show rocker switch OF-DPA flow tables
-------------------------------------

Arguments:

- "name": switch name
- "tbl-id": (optional) flow table ID

Example:

-> { "execute": "query-rocker-of-dpa-flows", "arguments": { "name": "sw1" } }
<- { "return": [ {"key": {"in-pport": 0, "priority": 1, "tbl-id": 0},
                  "hits": 138,
                  "cookie": 0,
                  "action": {"goto-tbl": 10},
                  "mask": {"in-pport": 4294901760}
                 },
                 {...more...},
   ]}

Show rocker OF-DPA group tables
-------------------------------

Arguments:

- "name": switch name
- "type": (optional) group type

Example:

-> { "execute": "query-rocker-of-dpa-groups", "arguments": { "name": "sw1" } }
<- { "return": [ {"type": 0, "out-pport": 2, "pport": 2, "vlan-id": 3841,
                  "pop-vlan": 1, "id": 251723778},
                 {"type": 0, "out-pport": 0, "pport": 0, "vlan-id": 3841,
                  "pop-vlan": 1, "id": 251723776},
                 {"type": 0, "out-pport": 1, "pport": 1, "vlan-id": 3840,
                  "pop-vlan": 1, "id": 251658241},
                 {"type": 0, "out-pport": 0, "pport": 0, "vlan-id": 3840,
                  "pop-vlan": 1, "id": 251658240}
   ]}

query-gic-capabilities
---------------

Return a list of GICCapability objects, describing supported GIC
(Generic Interrupt Controller) versions.

Arguments: None

Example:

-> { "execute": "query-gic-capabilities" }
<- { "return": [{ "version": 2, "emulated": true, "kernel": false },
                { "version": 3, "emulated": false, "kernel": true } ] }

Show existing/possible CPUs
---------------------------

Arguments: None.

Example for pseries machine type started with
-smp 2,cores=2,maxcpus=4 -cpu POWER8:

-> { "execute": "query-hotpluggable-cpus" }
<- {"return": [
     { "props": { "core-id": 8 }, "type": "POWER8-spapr-cpu-core",
       "vcpus-count": 1 },
     { "props": { "core-id": 0 }, "type": "POWER8-spapr-cpu-core",
       "vcpus-count": 1, "qom-path": "/machine/unattached/device[0]"}
   ]}'

Example for pc machine type started with
-smp 1,maxcpus=2:
    -> { "execute": "query-hotpluggable-cpus" }
    <- {"return": [
         {
            "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
            "props": {"core-id": 0, "socket-id": 1, "thread-id": 0}
         },
         {
            "qom-path": "/machine/unattached/device[0]",
            "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
            "props": {"core-id": 0, "socket-id": 0, "thread-id": 0}
         }
       ]}
